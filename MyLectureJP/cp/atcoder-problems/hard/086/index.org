* 086 D - Coloring Dominoes
- created: 2022-12-17 sat
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../../fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/ABC071)
- [公式ページ](https://atcoder.jp/contests/abc071/tasks/arc081_b)
** 入出力
共通の入出力です.

```fsharp
let N = stdin.ReadLine() |> int
let S1 = stdin.ReadLine()
let S2 = stdin.ReadLine()
solve N S1 S2 |> stdout.WriteLine
```
** 解説1
再帰で素朴に実装します.
*** 補助関数
まずは補助関数を準備します.

```
  let MOD = 1_000_000_007L
  let (.*) x y = (x*y)%MOD
  let isVertical i = S1.[i]=S2.[i]
```

`MOD`はまさに余りを取るための数です.
.NETでは数値を`_`で区切って読みやすく書けます.
`Int32`でも問題ないとは思うものの,
念のため`L`をつけて`Int64`にします.

`let (.*)`と括弧をつけると演算子が定義できます.
計算結果を`%`で処理し忘れないように全てこの演算子で計算します.

あと公式解説でいう`X`(縦並び)判定用の関数として`isVertical`を用意しました.
*** 再帰関数
まず先頭から確認をはじめます.
縦が一致していたら`3`をかけて`1`進め,
そうでなければ横の並びと判定して`6`をかけて`2`進めます.
最後まで来たら積んできた値を返します.
したがって次の処理ではじめればいいでしょう.

```
  let rec frec acc i =
    if i=N then acc
    elif i=0 then if isVertical i then frec (acc.*3L) (i+1) else frec (acc.*6L) (i+2)
    else
      "残りの処理"

  frec 1L 0 // 呼び出し
```

あとは地道に各`i`に対して前後を比べて処理します.
公式解説の判定をミスなく実装するだけです.

```
  let rec frec acc i =
    if i=N then acc
    elif i=0 then if isVertical i then frec (acc.*3L) (i+1) else frec (acc.*6L) (i+2)
    else
      match isVertical (i-1), isVertical i with
        | true,true   -> frec (acc.*2L) (i+1)
        | false,true  -> frec acc       (i+1)
        | true,false  -> frec (acc.*2L) (i+2)
        | false,false -> frec (acc.*3L) (i+2)
  frec 1L 0
```

読みづらくも書きにくくもなく,
程々の長さの実装で問題はないでしょう.
** 解説2
公式解説を参考に[Haskell実装](https://atcoder.jp/contests/abc071/submissions/22299505)を参考に実装します.
*** 方針
大事なのは縦並びか横並びかで,
文字が続くかどうかを判定すればよく,
いちいち二つの文字列を比べなくても一つの文字列だけ見れば判定できます.
一つの文字列を見て縦並び・横並びを判定したリストを作っておいて,
前後のペアを順に確認すれば目的の処理が完遂できます.

本質的には変わりませんが,
こちらは再帰ではなく`fold`で実装します.
*** 補助関数
解説1と同じ補助関数を準備します.

```fsharp
  let MOD = 1_000_000_007L
  let (.*) x y = (x*y)%MOD
```
*** 文字列の処理
F#の`List.group`と違い,
Haskellの`Data.List.group`は文字列を先頭から見て同じ文字が続く限りグループ化する関数です.
具体的には次のような挙動を取ります.

```fsharp
#r "nuget: FsUnit"
open FsUnit

    let rec group = function
      | [] -> []
      | x::xs ->
        let ys = List.takeWhile ((=) x) xs
        let zs = List.skipWhile ((=) x) xs
        (x::ys)::group zs
    group (List.ofSeq "Mississippi") |> should equal [['M'];['i'];['s';'s'];['i'];['s';'s'];['i'];['p';'p'];['i']]
```

ここで定義した再帰関数の`group`がHaskellの`Data.List.group`のF#実装です.
これを使って文字のリストに分割し,
内部の各リストの長さを取れば`1`のときは縦並び,
`2`のときは横並びです.

```fsharp
  let patterns = S1 |> Seq.toList |> group |> List.map (List.length)
```

サンプルの実行結果は次の通りです.

```fsharp
#r "nuget: FsUnit"
open FsUnit

let S1 = "RvvttdWI"
S1 |> Seq.toList |> group |> should equal [['R'];['v';'v'];['t';'t'];['d'];['W'];['I']]
S1 |> Seq.toList |> group |> List.map (List.length) |> should equal [1;2;2;1;1;1]
```
*** 大枠
先程定義した`patterns`を処理します.
初項によって初期値は`3`か`6`か変わります.
縦か横かは既に判定済みなため,
前後のペアを`List.pairwise`で素直に作って順次確認すれば十分です.
これをまとめると次のように`fold`が書けます.

```fsharp
  let patterns = S1 |> Seq.toList |> group |> List.map (List.length)
  let hp = List.head patterns
  List.pairwise patterns |> List.fold f (if hp=1 then 3L else 6L)
```

関数`f`は解説1と本質的に同じで次のように書けます.

```fsharp
  let f acc = function
    | (1,1) -> acc.*2L
    | (1,2) -> acc.*2L
    | (2,1) -> acc
    | _     -> acc.*3L
```

全体をまとめましょう.

```fsharp
let solve N (S1:string) =
  let MOD = 1_000_000_007L
  let (.*) x y = (x*y)%MOD

  let rec group = function
    | [] -> []
    | x::xs -> let ys = List.takeWhile ((=) x) xs in let zs = List.skipWhile ((=) x) xs in (x::ys)::group zs
  let f acc = function
    | (1,1) -> acc.*2L
    | (1,2) -> acc.*2L
    | (2,1) -> acc
    | _     -> acc.*3L

  let patterns = S1 |> Seq.toList |> group |> List.map (List.length)
  let hp = List.head patterns
  List.pairwise patterns |> List.fold f (if hp=1 then 3L else 6L)

let N = stdin.ReadLine() |> int
let S1 = stdin.ReadLine()
solve N S1 |> stdout.WriteLine
```
