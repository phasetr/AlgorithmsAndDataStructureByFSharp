* 087 D - Friend Suggestions
- created: 2022-12-18 sun
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../../byfs/fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/ABC157)
- [公式ページ](https://atcoder.jp/contests/abc157/tasks/abc157_d)
- - 要点: アルゴリズムの検討・実装
** 入出力
```
let N,M,K = stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1],x.[2]
let Xa = Array.init M (fun _ -> stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1])
let Ya = Array.init K (fun _ -> stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1])
solve N M K Xa Ya |> Array.map string |> String.concat " " |> stdout.WriteLine
```
** 解説
練習も兼ねて(破壊的な)Union-Findを簡易実装して対応します.
提出された解答を眺めていたら,
少なくともRustではpetgraph crateがあってAtCoderでも使えるようです.
*** 破壊的な簡易Union-Find
クラスとしての実装は[UnionFind.fsx](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/DataStructures/UnionFind.fsx)に置いてあります.

```fsharp
  type UnionFind = { par: int[]; size: int[]}
  let uf = { par = Array.init N id; size = Array.create N 1 }

  let rec root x =
    if uf.par.[x] = x then x
    else let r = root uf.par.[x] in uf.par.[x] <- r; r
  let find x y = root x = root y
  let unite x y =
    let rx,ry = root x, root y
    if rx=ry then false
    else
      let large,small = if uf.size.[rx]<uf.size.[ry] then ry,rx else rx,ry
      uf.par.[small] <- large
      uf.size.[large] <- uf.size.[large]+uf.size.[small]
      uf.size.[small] <- 0
      true
  let size x = let rx = root x in uf.size.[rx]
```
*** 入力の変換
直接的な友達・ブロックの隣接行列を作りながらUnion-Find木を作ります.
隣接行列は.NETの`ResizeArray()`の`Add`でゴリゴリと破壊的に作ります.

```fsharp
  let Fa = Array.init N (fun _ -> ResizeArray<int>())
  Xa |> Array.iter (fun (a0,b0) ->
    let a,b = a0-1,b0-1
    Fa.[a].Add(b); Fa.[b].Add(a); unite a b |> ignore)
  let Ba = Array.init N (fun _ -> ResizeArray<int>())
  Ya |> Array.iter (fun (c0,d0) ->
    let c,d = c0-1,d0-1
    Ba.[c].Add(d); Ba.[d].Add(c))
```

`Fa`が友達(friends),
`Ba`がブロックの配列です.
入力の`Xa`の処理の中で`unite a b`をかませてUnion-Find木を作っています.
*** 最終的な計算
公式解説通り次の量を計算します.

```
(頂点 i の連結成分のサイズ)
− (頂点 i と頂点 j が同じ連結成分に含まれて、人 i と人 j が友達関係もしくはブロック関係にある j の数)
− 1
```

各頂点`i`に対して連結成分のサイズは`size i`,
友達関係にある頂点`j`の数は`Fa.[i].Count`で計算できます.
ブロック関係にある頂点`j`の数は`Union-Find`の`find`を使って次の処理で計算できます.

```fsharp
    let blocks = Ba.[i].ToArray() |> Array.sumBy (fun b -> if find i b then 1 else 0)
```

あとは各頂点ごとの計算を次のように`Array.map`で処理します.

```fsharp
  [|0..N-1|]
  |> Array.map (fun i ->
    let blocks = Ba.[i].ToArray() |> Array.sumBy (fun b -> if find i b then 1 else 0)
    size i - Fa.[i].Count - blocks - 1)
```
*** まとめ
```fsharp
type UnionFind = { par: int[]; size: int[]}
let solve N M K Xa Ya =
  let uf = { par = Array.init N id; size = Array.create N 1 }

  let rec root x =
    if uf.par.[x] = x then x
    else let r = root uf.par.[x] in uf.par.[x] <- r; r
  let find x y = root x = root y
  let unite x y =
    let rx,ry = root x, root y
    if rx=ry then false
    else
      let large,small = if uf.size.[rx]<uf.size.[ry] then ry,rx else rx,ry
      uf.par.[small] <- large
      uf.size.[large] <- uf.size.[large]+uf.size.[small]
      uf.size.[small] <- 0
      true
  let size x = let rx = root x in uf.size.[rx]

  let Fa = Array.init N (fun _ -> ResizeArray<int>())
  Xa |> Array.iter (fun (a0,b0) ->
    let a,b = a0-1,b0-1
    Fa.[a].Add(b); Fa.[b].Add(a); unite a b |> ignore)
  let Ba = Array.init N (fun _ -> ResizeArray<int>())
  Ya |> Array.iter (fun (c0,d0) ->
    let c,d = c0-1,d0-1
    Ba.[c].Add(d); Ba.[d].Add(c))

  [|0..N-1|]
  |> Array.map (fun i ->
    let blocks = Ba.[i].ToArray() |> Array.sumBy (fun b -> if find i b then 1 else 0)
    size i - Fa.[i].Count - blocks - 1)

let N,M,K = stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1],x.[2]
let Xa = Array.init M (fun _ -> stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1])
let Ya = Array.init K (fun _ -> stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1])
solve N M K Xa Ya |> Array.map string |> String.concat " " |> stdout.WriteLine
```
