* 076 C - たくさんの数式
- created: 2022-12-12 mon
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../../byfs/fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/ARC061)
- [公式ページ](https://atcoder.jp/contests/abc045/tasks/arc061_a)
- [公式解説](https://atcoder.jp/contests/abc045/editorial)
** 解説
文字列がもっと長いと気になってはくるものの,
(末尾再帰ではない)再帰でさっと書いてしまえばいいでしょう.
Haskellでは`foldM`などで豪快な処理が書けるものの,
(今の私のF#の腕前では)シンプルな移植ができないのも理由の一つです.

計算用の再帰関数は次のように実装できます.

```fsharp
  let rec frec a y = function
    | [] -> a+y
    | x::xs -> frec (a+y) x xs + frec a (y*10L + x) xs
```

入力の文字列を一桁数値のリストに変換する処理は次のように書けます.

```fsharp
  let ys = S |> Seq.map (fun c -> int64 c - int64 '0') |> Seq.toList
```

ここで`1`を単に`int64 c`だけにすると`49L`が返ってきてはまり倒します.
上のように`int64 '0'`を引いて整数として`1L`が返るようにするか,
`c |> string |> int64`のように文字列にしてから`int64`を通しましょう.
例を見るとわかるように`Int32`の範囲を飛び越えるため,
オーバーフロー対策で`Int64`を使うのは必須です.

** その他
逐次計算していくのではなく,
いったん文字列から必要な数を切り出す(ベキ集合を作る)タイプの実装でHaskellコードを見ると,
`replicateM`を使ってブーリアンのベキ集合を使ってどの文字を取ってくるか判定しています.
[Reference.fsx](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/blob/master/Library/References.fsx)を`replicateM`か`ベキ集合`で検索すれば対応する関数のリスト版実装があります.
これを参考にHaskellコードの移植を考えてもいいでしょう.
