* 099 B - Simplified mahjong
- created: 2022-12-25 sun
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../../fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/AGC003)
- [公式ページ](https://atcoder.jp/contests/agc003/tasks/agc003_b)
- 要点: アルゴリズムの検討
** 入出力
```fsharp
let N = stdin.ReadLine() |> int
let Ia = Array.init N (fun _ -> stdin.ReadLine() |> int64)
solve N Ia |> stdout.WriteLine
```
** 解説
*** 方針
公式解説とは違い, 次の方針で前から順に計算します.

- 各`i`ごとに自分自身でペアを作れるだけ作る.
- 各`i`ごとにあまりは一枚出るか出ないかで, これを次に持ち越す.
- 前の`i`であまりがあった場合は, 積み残しとのペアを考えつつ自分自身でペアを作れるだけ作る.

次の`fold`で素直に処理できます.

```fsharp
  ((0L,0L), Ia)
  ||> Array.fold (fun (acc,m) a -> "条件分岐を書く"
  |> fst
```

`acc`がペアの数を積む変数で`m`があまりの有無を表します.
最後に必要なのはペアの数を表すタプルの第一変数だから`fst`で切り出します.
*** `fold`内の条件分岐
まずあまりがなかった場合はごく単純に次のように書けます.

```fsharp
    if m=0L then let (q,r) = (a/2L,a%2L) in (acc+q,r)
```

次の二つはあまりがないときの分岐です.
まず入力の`A_i`が`0`の場合はペアを作りようがないためそのまま次に回します.

```fsharp
    elif a=0L then (acc,0L)
```

今度は入力の`A_i`が非零の値を持つため,
前からの積み残しの分を考えて計算します.

```fsharp
    else let (q,r) = ((a-1L)/2L, (a-1L)%2L) in (acc+q+1L,r))
```

積み残しと一つペアを作るため,
次に積み回すための商とあまりの`q,r`は`a-1`から計算します.
さらに`a-1`で計算した以上ペアがもう一つできているためペアのカウントは`acc+q+1`で`+1`が必要です.
*** まとめ
```fsharp
let solve N Ia =
  ((0L,0L), Ia)
  ||> Array.fold (fun (acc,m) a ->
    if m=0L then let (q,r) = (a/2L,a%2L) in (acc+q,r)
    elif a=0L then (acc,0L)
    else let (q,r) = ((a-1L)/2L, (a-1L)%2L) in (acc+q+1L,r))
  |> fst

let N = stdin.ReadLine() |> int
let Ia = Array.init N (fun _ -> stdin.ReadLine() |> int64)
solve N Ia |> stdout.WriteLine
```
