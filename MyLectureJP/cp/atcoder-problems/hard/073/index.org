* 073 C - Strange Bank
- created: 2022-12-03 sat
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../byfs/fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/ABC099)
- [公式ページ, ABC099](https://atcoder.jp/contests/abc099/tasks/abc099_c)
** 解答1: 公式解説, シンプルなループ処理
公式解説の処理をF#で単純に書き直すなら[このコード](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/ABC099/C_fs_02.fsx)のようになるでしょう.

```fsharp
open System
let n : int = int(Console.ReadLine())
let mutable res = n
let mutable i = 0
while i <= n do
    let mutable cc = 0
    let mutable t = i
    while t > 0 do
        cc <- cc + t % 6
        t <- t / 6
    t <- n - i
    while t > 0 do
        cc <- cc + t % 9
        t <- t / 9
    if res > cc then
        res <- cc
    i <- i + 1
printfn "%d" res
```

最初の`while i <=n do`は`for`で簡単に書き換えられるとして,
可変変数を不変変数に置き換えつつ,
内部の`while t > 0 do`をどう関数型らしく書き換えるかがまず問題です.
[F#解説](../../../byfs/fsharp-for-cp/index.md)に書いたように再帰で書き換えます.

`t`は各`while`の直前で設定し直していて最終的に`cc`を返せばよいため,
`t`は単純に関数の入力パラメータにすればよいでしょう.
`6`で割る`while`ループを表す再帰関数は次のように書けます.

```fsharp
let rec frec cc t = if t>0 then frec (cc+t%6) (t/6) else cc
```

正の数を正の数で割り続けたあまりは`0`になるため,
`then`節が短くなるように条件式を書き換えています.
`9`で割り続ける処理は`mod k`の`k`が変わるだけで同じ処理です.
それもまとめた再帰関数は次のように書けます.

```fsharp
let rec frec k cc t = if t>0 then frec k (cc+t%k) (t/k) else cc
```

次にメインの`while i<=n do`を考えます.
これは最終的に積んだ値`res`を返すループだから`fold`を使えばよいでしょう.
結論としては次のように書けます.

```fsharp
let solve N =
  let rec frec k cc t = if t>0 then frec k (cc+t%k) (t/k) else cc
  (N,[|0..N|]) ||> Array.fold (fun res i ->
    let cc6 = frec 6 0 i
    let cc9 = frec 9 cc6 (N-i)
    if res <= cc9 then res else cc9)
```

最後の`if`式では`else`をつけ忘れないようにしましょう.
もちろんつけないと型エラーで動きません.

最後に, そもそも意味がわからずはまり倒したため,
`let cc6 = frec 6 0 i; let cc9 = frec 9 cc6 (N-i)`で何をしているかを説明する自分用のメモ.
まず次のように書き換えて考えるといいでしょう.

```fsharp
    let cc6 = frec 6 0 i
    let cc9 = frec 9 0 (N-i)
```

こうすると次のように意味がはっきりします.

- `cc6`: `i`を`6`のベキだけで処理した回数
- `cc9`: 残りの`N-i`を`9`のベキだけで処理した回数

あとは全探索の部分です.
ある数`i`を`6`のベキで処理し切ったら残りの`N-i`は`9`のベキで処理するしかありません.
これを全探索で全ての`i`に対して確認しています.
** 解説2: ユーザ解説, メモ化再帰
[ユーザ解説](https://blog.hamayanhamayan.com/entry/2018/06/15/003759)はDPで解いています.
私の前にF#で[DPで解いている人](https://atcoder.jp/contests/abc099/submissions/8976622)がいます.
実行時間も短いためこれも考えてみましょう.
上記コードはちょっと長いため単純化したコードを紹介します.
2022-12時点で全てではないものの,
[Educational DP Contest / DP まとめコンテスト](https://atcoder.jp/contests/dp/submissions?f.Task=&f.LanguageName=&f.Status=AC&f.User=simin)にF#で取り組んだ結果があるため,
こちらも参考にしてください.
(2022-12時点では特にHaskell・OCamlコードを焼き直しただけで,
私は自力でDPを解く力量がありません.)

まずF#版の`array6`と`array9`にあたる配列生成を考えます.
もちろんいくつか書き方はあり,
比較的簡潔なのは次のコードでしょうか.

```
  let rec p k x acc = if x>N then (acc-1) else p k (k*x) (acc+1)
  let array6 = [|0..(p 6 1 0)|] |> Array.map (pown 6)
  let array9 = [|0..(p 9 1 0)|] |> Array.map (pown 9)
```

再帰関数の`p`はベキを何回まで取ればいいか計算する関数です.

次は本丸のメモ化再帰です.
定型的な書き方があるため,
コピペで使えるように[Reference.fsx](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/blob/master/Library/References.fsx)にメモしています.

まずはコードを示してそれにコメントしましょう.

```fsharp
  let memorec f =
    let memo = System.Collections.Generic.Dictionary<_,_>()
    let rec frec j =
      match memo.TryGetValue j with
        | exist, value when exist -> value
        | _ -> let value = f frec j in memo.Add(j, value); value
    frec
  let count frec n =
    if n=0 then 0
    else
      let c1 = n - (array6 |> Array.findBack (fun x -> x<=n))
      let c2 = n - (array9 |> Array.findBack (fun x -> x<=n))
      1 + min (frec c1) (frec c2)
  (memorec count) N
```

メモ化の部分が`let memorec f`です.
`let memo = System.Collections.Generic.Dictionary<_,_>()`はF#の`Map`ではなく`.NET`の辞書を読んでいます.
`memo.Add`で破壊的に書き換わってくれた方が便利だからです.
`let rec frec j`はメモがあればその値を返し,
ない場合は値を詰めて返します.

処理の本体が`count`です.
第一引数の`frec`は`memorec`中で`frec`として呼び出す関数で,
対応を明確にするために名前を揃えています.

まず`c1`から考えましょう.
`6`のベキで大きい方から削るため,
`(array6 |> Array.findBack (fun x -> x<=n))`で削れる中で最大の数を取ります.
`c1`は削って残った数で,
`frec c1`でメモ化再帰または動的計画法で`c1`に辿り着くまでの最小操作回数が取れます.
実際に`count`関数の`else`節で`printfn "%A" (c1,c2,frec c1, frec c2)`で出力して確認してみてください.

同じ計算を`9`に対しても適用して,
小さい方を取れば最小回数が得られます.
最後に`1`を足すのは`min (frec c1) (frec c2)`は最終ステップ一手前の値だからです.

あとは`count`に`memorec`でガワをかぶせて計算すれば求める結果が得られます.
メモ化のための辞書`memo`をクロージャー`memorec`で隠蔽している分コードが読みにくいかもしれません.
[オリジナル](https://atcoder.jp/contests/abc099/submissions/8976622)は最終的に呼び出す関数が素直な再帰になっているため,
こちらの方がわかりやすいかもしれません.
