* 78 C K-th Substring
- created: 2022-12-13 tue
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../../fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/ABC097)
- [公式ページ](https://atcoder.jp/contests/abc097/tasks/arc097_a)
- [公式解説](https://atcoder.jp/contests/abc097/editorial)
** 解説
公式解説の方針そのままの実装を考えます.
条件をみたす部分文字列をどう作るかがポイントで,
今回の条件ではとにかく手当たり次第に作ると諦めるのが肝心です.

文字列の各`i`番目から`i+K-1`番目までの部分文字列を作り倒すには,
例えば次のように書けばよいでしょう.

```fsharp
  let S,K = "aba",4
  let n = S.Length - 1
  [|0..n|] |> Array.map (fun i -> [|i..(min n (i+K-1))|] |> Array.map (fun j -> S.[i..j]))

  // val it: string[][] = [|[|"a"; "ab"; "aba"|]; [|"b"; "ba"|]; [|"a"|]|]
```

この返り値はもちろん文字列の配列の配列で,
型は`string[][]`です.
これをフラットにする,
つまり`string[]`にするには`Array.concat`を作用させればよいです.
しかし標準で`Array.map`の結果を`Array.concat`してくれる関数`Array.collect`があるため,
素直にこれを使えばいいでしょう.

```fsharp
  let S,K = "aba",4
  let n = S.Length - 1
  [|0..n|] |> Array.collect (fun i -> [|i..(min n (i+K-1))|] |> Array.map (fun j -> S.[i..j]))

  // val it: string[] = [|"a"; "ab"; "aba"; "b"; "ba"; "a"|]
```

上の出力を見るとわかるように`"a"`が二つ出てきます.
あとはこの重複を`Array.distinct`で潰し,
`Array.sort`して`K`番目を取れば終わりです.
