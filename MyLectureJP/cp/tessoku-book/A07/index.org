* A07 - Event Attendance
- created: 2022-12-27 tue
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../byfs/fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/tessoku-book/A07)
- [公式ページ](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_g)
- 要点: アルゴリズム, ループを減らす
** 入出力
```fsharp
let D = stdin.ReadLine() |> int
let N = stdin.ReadLine() |> int
let Ia = Array.init N (fun _ -> stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1])
solve D N Ia |> Array.iter stdout.WriteLine
```
** 方針
これも前問A06と同じくどうループを減らすかが問題です.
このデータ数で速い言語なら無理を通せるものの,
明らかな無駄は省くべきでもあります.
さらにA06と同じくあとの処理を綺麗に書くための前処理もポイントです.
もちろん前回と違って今回は各日の出席者数の勘定で,
何日から何日までの指定ではない点も注意が必要です.

結論から言えば入力`Ia`を使って`i`日に何人の出入りがあったかを勘定します.

- `li`を使って`i`日に人が一人入った.
- `ri`を使って`i+1`日に人が一人抜けた.

こう考えて出欠を管理すれば計算できます.
上記の`ri`の処理で`i+1`を考えているため,
配列で処理する場合は配列外参照の実行時エラーを起こさないように注意しましょう.
特に`ri = D`がありるため,
途中に出てくる配列の要素数は`D+1`にしなければいけません.
実際私は提出コードで一回`RE`を出してしまいました.
テストケースをきちんと考えれば防げた問題でもあり,
テストケース生成の重要性もわかります.
** 解説
*** 出欠管理
方針で書いた内容を素直に実装します.

```fsharp
  (Array.create (D+1) 0, Ia)
  ||> Array.fold (fun Xa (l,r) -> Xa.[l-1] <- Xa.[l-1]+1; Xa.[r] <- Xa.[r]-1; Xa)
```

`Array.create (D+1)`が重要です.
配列の添字は`1`-originではなく`0`-originである点にも注意しましょう.
*** 累積和
これも単純に`scan`で十分です.

```fsharp
  (Array.create (D+1) 0, Ia)
  ||> Array.fold (fun Xa (l,r) -> Xa.[l-1] <- Xa.[l-1]+1; Xa.[r] <- Xa.[r]-1; Xa)
  |> Array.scan (+) 0
```
*** 必要な要素の切り出し
今回も初項`0`が余計です.
さらに`D+1`で配列を生成したため最終項も余計です.
スライスで次のように書けばいいでしょう.

```fsharp
  (Array.create (D+1) 0, Ia)
  ||> Array.fold (fun Xa (l,r) -> Xa.[l-1] <- Xa.[l-1]+1; Xa.[r] <- Xa.[r]-1; Xa)
  |> Array.scan (+) 0
  |> fun Xa -> Xa.[1..(Xa.Length-2)]
```

ここも`0`-originの配列で後ろから二つめを取るには`Xa.Length-2`であって,
`Xa.Length-1`ではない点に注意します.
