* A09 - Winter in ALGO Kingdom
- created: 2022-12-27 tue
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../byfs/fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/tessoku-book/A09)
- [公式ページ](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_i)
- 要点: アルゴリズム, ループを減らす
** 入出力
```fsharp
let H,W,N = stdin.ReadLine().Split() |> Array.map int |> (fun x -> x.[0],x.[1],x.[2])
let Ia = Array.init N (fun _ -> stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1],x.[2],x.[3])
solve H W N Ia |> Array.iter (Array.map string >> String.concat " " >> stdout.WriteLine)
```
** 方針
これもやはり典型的な処理です.
二次元になって積み方にもう一捻り必要になっただけで[A07](../A07/index.md)と本質的に同じです.
方針さえはっきりすれば,
実装で問題になるのは最後の余計な要素を削る部分の添字の指定ミス程度でしょう.
正しい実装を導くために入力例をうまく使うと便利です.
** 解説
方針にも書いたように基本は[A07](../A07/index.md)と本質的に同じです.
ここでは大幅に解説を省略します.

結論から言えば入力の二次元配列への積み方は次の通りです.

```fsharp
  (Array.init (H+1) (fun _ -> Array.create (W+1) 0), Ia)
  ||> Array.fold (fun Xa (a,b,c,d) ->
    Xa.[a-1].[b-1] <- Xa.[a-1].[b-1]+1;
    Xa.[a-1].[d] <- Xa.[a-1].[d]-1;
    Xa.[c].[b-1] <- Xa.[c].[b-1]-1;
    Xa.[c].[d] <- Xa.[c].[d]+1;
    Xa)
```

`(a-1,d)`と`(c,b-1)`に`-1`を追加し,
`(c,d)`に`+1`を追加するのがポイントです.
`(a-1,b-1)`で立てた追加フラグを削除するのがこの二つの指定です.
余計なマイナスを削るためにさらに`(c,d)`に`+1`を追加します.
これで必要な領域にだけ`+1`できます.

あとは横に足してから縦を足します.

```fsharp
  (Array.init (H+1) (fun _ -> Array.create (W+1) 0), Ia)
  ||> Array.fold (fun Xa (a,b,c,d) ->
    Xa.[a-1].[b-1] <- Xa.[a-1].[b-1]+1;
    Xa.[a-1].[d] <- Xa.[a-1].[d]-1;
    Xa.[c].[b-1] <- Xa.[c].[b-1]-1;
    Xa.[c].[d] <- Xa.[c].[d]+1;
    Xa)
  |> Array.map (Array.scan (+) 0)
  |> Array.scan (Array.map2 (+)) (Array.create (W+2) 0)
```

これは`scan (+) 0`の影響で二つついた余計な項を次のようなスライスで落とします.

```fsharp
  (Array.init (H+1) (fun _ -> Array.create (W+1) 0), Ia)
  ||> Array.fold (fun Xa (a,b,c,d) ->
    Xa.[a-1].[b-1] <- Xa.[a-1].[b-1]+1;
    Xa.[a-1].[d] <- Xa.[a-1].[d]-1;
    Xa.[c].[b-1] <- Xa.[c].[b-1]-1;
    Xa.[c].[d] <- Xa.[c].[d]+1;
    Xa)
  |> Array.map (Array.scan (+) 0)
  |> Array.scan (Array.map2 (+)) (Array.create (W+2) 0)
  |> fun Xa -> Xa.[1..H] |> Array.map (fun Ra -> Ra.[1..W])
```
