* A04 - Binary Representation 1
- created: 2022-12-26 mon
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../byfs/fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/tessoku-book/A04)
- [公式ページ](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_d)
- 要点: 定型処理・零埋め(ゼロパディング)
** 入出力
```fsharp
let N = stdin.ReadLine() |> int
solve N |> stdout.WriteLine
```
** 方針
よく出てくる定型処理です.
暗記してもいいほどです.
自分用のライブラリを作って記録しておくといいでしょう.
私は[Arithmetics.fsx](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/blob/master/Library/Arithmetics.fsx)に記録しています.
** 解説1: 再帰
*** 大枠
今回入力の`N`は`1`以上の自然数です.
しかし`N=0`で問題(?)がある実装を紹介するため,
念のため場合分けを明確につけておきます.

結論からいうと再帰関数で`0,1`の数値からなるリストとして二進展開を作ります.
最初に書いたように`N=0`の場合を別にして次のように書きます.

```fsharp
  let rec frec acc N = if N=0 then acc else "再帰処理"
```

これで`[1;1;0;1]`のようなリスト(`int list`)ができます.
ここから二進展開の文字列を作って文字列を零埋めします.
零埋めのよい方法がいまだによくわかっていないものの,
C#の文字列系のメソッドを使えばいいでしょう.
リストを文字列に変換して文字列を零埋めします.

```fsharp
  if N=0 then [0] else frec [] N |> List.map string |> String.concat "" |> fun s -> s.PadLeft(10,'0')
```

`frec [] N`以降は次のように処理しています.

- `List.map string`で`int list`を`string list`に変換する.
- `System.String.concat ""`で`string list`を空文字列で連結する.
- `s.PadLeft`で文字列に対して零埋めする.
*** 再帰関数の構成を考える
いきなり二進展開で考えるとわかりにくいでしょう.
`K=10`として十進数を十進展開し,
最後に`K=2`で置き換えると多少なりともわかりやすいはずです.

まず十進展開されたもとの数を`N`とします.
特に`N = 123456789`として, これの一番下から`K`進展開を考えます.
一番下の桁は`9`だから何とかして`N`から`9`を切り出します.
これを`N`を`K = 10`で割ったあまりとみなせば`N%K`で`9`が取れます.
次に`N/K`を考えると一番下の桁が削れて`N1 = 12345678`が得られます.
これに対してさらに`N1%K`を考えると`8`が得られます.
これを再帰的に続けて`Nk = 0`になるまで続ければ求める十進展開が得られます.

箇条書きでは次のように書けます.

- `K`進展開したい数を`N`とする.
- 最低桁を取る.
    - `N%K`で最低桁が得られるからこの値を積む.
    - 次の桁を得るために`N1 = N/K`を次のステップに回す.
- 二桁目を取る.
    - `N1%K`で`N1`の最低桁, `N`の二桁目が得られるからこの値を積む.
    - 次の桁を得るために`N2 = N1/K`を次のステップに回す.
- これを`Nk = 0`までくり返す.
*** 再帰関数を書く
結論だけ書きます.

```fsharp
  let rec frec acc N = if N=0 then acc else frec ((N%2)::acc) (N/2)
```
** 解説2: `unfold`
[F#入門コンテンツ](https://phasetr.com/archive/fc/pg/cp/byfs/fsharp-for-cp/)でループは再帰の構文糖衣とみなせると書きました.
特にループは配列から配列を作るか,
配列から値を作るか二通りあると書きました.
今回の処理は再帰を使って値から配列(リスト)を生成しています.
特定の場合にはこの逆の処理をしてくれる関数があり,
それは`unfold`です.
慣れないと難しいため無理に使う必要はありません.
しかし関数型言語による処理では時々顔を見せる関数であるため,
念のため紹介します.

本質的には再帰と同じで,
関数についてはリファレンスを見てもらうとして簡潔に結果だけ示します.

```fsharp
let solve N =
  if N=0 then [|0|] else N |> Array.unfold (fun n -> if n=0 then None else Some (n%2,n/2))
  |> Array.rev
  |> Array.map string |> String.concat "" |> fun s -> s.PadLeft(10,'0')
```

`unfold`を使う場合は再帰と違って`Array.rev`で順序を反転する必要があります.
