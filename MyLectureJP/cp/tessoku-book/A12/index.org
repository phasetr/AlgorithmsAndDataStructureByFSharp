* A12 - Printer
- created: 2022-12-28 wed
- ご意見・ご要望は[issue・プルリク用のGitHub](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/MyLectureJP/cp)まで
- [競技プログラミングのためのF#入門](../../byfs/fsharp-for-cp/index.md)
- [GitHub上の対応ディレクトリ](https://github.com/phasetr/AlgorithmsAndDataStructureByFSharp/tree/master/AtCoder/tessoku-book/A12)
- [公式ページ](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_l)
- 要点: アルゴリズム
** 入出力
```fsharp
let N,K = stdin.ReadLine().Split() |> Array.map int64 |> (fun x -> x.[0],x.[1])
let Ia = stdin.ReadLine().Split() |> Array.map int64
solve N K Ia |> stdout.WriteLine
```
** 方針
二つ要点があります.
一つは何回目で実現できるかに関連して二分探索を思いつけるか,
二分探索を思いつけたとしてどう実装するかです.

ここでは後者の二分探索で何をどう調べるか考えましょう.
ある`m`秒目で必要な枚数が印刷できたかどうかを調べる必要があります.
問題設定からその時間までに各`i`番目のプリンターは`m/Ai`枚印刷できています.
あとはこの総和を取って必要枚数印刷できたか確認します.
** 解説
命令型の言語では`while`で処理する方が多いように思います.
ここでは再帰関数で処理します.
二分探索はアルゴリズムのどの本にも載っているため細かい解説は省略します.

```fsharp
  let rec bsearch l r =
    if r<=l then l
    else
      let m = (l+r)/2L
      let s = Ia |> Array.sumBy (fun a -> m/a)
      if K<=s then bsearch l m
      else bsearch (m+1L) r
  bsearch 1L (pown 10L 9)
```

問題の制約で`答えは 10^9 を超えない`とあるため,
最大値(最初の`r`)は`r = 10^9`に取ればよいでしょう.
もちろん`1 \leq Ai`の仮定からも保証されます.

途中の印刷枚数確認は`Array.sumBy`で`mi/a`の和を積めば計算できます.
