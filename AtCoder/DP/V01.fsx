@"https://atcoder.jp/contests/dp/tasks/dp_v
N 頂点の木があります。
頂点には 1, 2, \ldots, N と番号が振られています。
各 i (1 \leq i \leq N - 1) について、
i 番目の辺は頂点 x_i と y_i を結んでいます。

太郎君は、各頂点を白または黒で塗ることにしました。
このとき、どの黒い頂点からどの黒い頂点へも、
黒い頂点のみを辿って到達できるようにします。

正整数 M が与えられます。
各 v (1 \leq v \leq N) について、次の質問に答えてください。

* 頂点 v が黒であるような頂点の色の組合せは何通りか？ M で割った余りを求めよ。

制約

* 入力はすべて整数である。
* 1 \leq N \leq 10^5
* 2 \leq M \leq 10^9
* 1 \leq x_i, y_i \leq N
* 与えられるグラフは木である。"
"""解説: https://kyopro-friends.hatenablog.com/entry/2019/01/12/231106
1つの頂点についてだけ答えればいいんだったら、
P問題と同じようにしてO(N)で求められるけど、
これを各頂点でやってたらO(N2)になって間に合わないんだよねー。
この問題みたいに「木の各頂点について～～であるようなものを求めよ」って問題は全方位木DPっていう方法で解けることが多いよ。
こういう感じのアルゴリズムだね。
１．適当な頂点を根にして木DPで問題を解く
２．根を子に移して問題を解く。このとき、今までに求めた情報を使い回す
３．繰り返す
詳しいアルゴリズムについてはこのブログが詳しいよ。
†全方位木DP†について - ei1333の日記
他にもsnukeさんのツイートも参考になるねー。

実はこの問題は、全方位木DPを知ってても"やるだけ"じゃないんだよねー。
まずはこの図を見てもらおうか。
(図省略)
左側でまず頂点1を根として問題を解いて、
次に根を頂点2に移して問題を解くことを考えるよ。
左側の図で頂点1を根として問題を解くときは、
頂点1で集める情報は「頂点2、頂点3、頂点4」の部分木に関する情報だね。
だけど右側の図で頂点2を根とするときは、
頂点1で集める情報は「頂点3、頂点4」の部分木に関する情報で、頂点2は親だから含まないねー。
同様に頂点3,4を根にすると、
頂点1で集める情報は「頂点2,4」「頂点2,3」になるから、
毎回情報を集め直してたら、ウニグラフ*1のときに全体でO(N2)になっちゃうんだよねー。
かといって「頂点2,3,4」に関する情報を集めておいて、
そこから「頂点2に関する情報を取り除く」ということも出来ないよ。
部分木の答えがmodMで0のときにゼロ除算になるからね。
どうすればいいかな？ちょっと問題をまとめ直しておこうか。

問題：頂点vと隣接する頂点の集合をUとする。Uに属する各頂点uに対し、
部分木に関する答えdp[u]が求まっている。
このとき、各uについて∏w≠udp[w]を高速に求めよ。

これも「累積和」を使うと解くことが出来るんだよね。
今回は掛け算だから「累積積」って言った方がいいかな？
こういう手順で求めるよ
１．Uの頂点に順序を付けて1,2,…,kとする。
２．前方1～iの累積積cum1[i]と、後方i～kの累積積cum2[i]を計算しておく
３．各u∈Uについて求める答えはcum1[u−1]∗cum2[u+1]
こうすれば前計算O(|U|)、本計算O(1)でできるから、全ての頂点についての答えがO(|U|)で求められるよ。
ここまで工夫すれば全体での計算量はO(N)

になって間に合うねー。いやー大変だよー。

…………ちなみに、私は本番ではこれを思いつかなくて、O(NlogN)で解いたんだよねー。
詳しくは解説しないけど、こんな感じの方法だよ。
１．Uの頂点に順序を付けて1,2,…,kとする。
２．f(l,r,s)という関数を「区間[l,r)に属する頂点について答えたい。この部分以外に関する積はs」とする
３．区間の長さが1ならsが答え。そうじゃないならm=(l+r)/2として、f(l,m,s′),f(m,r,s″)を再帰呼び出し
こうすると、二分法の要領でO(|U|log|U|)、
全体だとO(NlogN)で求められるねー。
やー、競技プログラミングの問題は解ければ正義だから、ゴリ押しも大事だよー？
"""
#r "nuget: FsUnit"
open FsUnit

let N,M,Aa = 3,100,[|(1,2);(2,3)|]
"TODO cf. V04.py, P01.fsx"
let solve N,M,Aa = 1

let N,M = stdin.ReadLine().Split() |> Array.map int |> (fun x -> x.[0], x.[1])
let Aa = [| for i in 1..(N-1) do (stdin.ReadLine().Split() |> Array.map int |> fun x -> x.[0],x.[1]) |]
solve N M Aa |> Array.map stdout.WriteLine

solve 3 100 [|(1,2);(2,3)|] |> should equal [|3;4;3|]
solve 4 100 [|(1,2);(1,3);(1,4)|] |> should equal [|8;5;5;5|]
solve 1 100 [||] |> should equal [|1|]
solve 10 2 [||] [|(8,5);(10,8);(6,5);(1,5);(4,8);(2,10);(3,6);(9,2);(1,7)|] |> should equal [|0;0;1;1;1;0;1;0;1;1|]
