@"https://atcoder.jp/contests/dp/tasks/dp_o
N 人の男性たちと N 人の女性たちがいます。
男性たちには 1, 2, \ldots, N と番号が振られています。
同様に、女性たちには 1, 2, \ldots, N と番号が振られています。

各 i, j (1 \leq i, j \leq N) について、
男性 i と女性 j の相性の良し悪しが整数 a_{i, j} によって与えられます。
a_{i, j} = 1 ならば男性 i と女性 j は相性が良く、a_{i, j} = 0 ならば相性が悪いです。

太郎君は、相性が良い男女どうしのペアを N 組作ろうとしています。
このとき、各男性および各女性はちょうど 1 つのペアに属さなければなりません。

N 組のペアを作る方法は何通りでしょうか？ 10^9 + 7 で割った余りを求めてください。

制約

* 入力はすべて整数である。
* 1 \leq N \leq 21
* a_{i, j} は 0 または 1 である。"
"""解説 https://kyopro-friends.hatenablog.com/entry/2019/01/12/231035
bitDPというテクニックを使う問題ね。
bitDPというのは、集合を数に変換して状態(=添字)として持つようなDPのことよ。
例えば{0,2,3}という集合は20+22+23=13という数に変換して、
「数iが集合に属しているか」と「i bit目が1か」を対応させるわ。
こうすると、「集合としてS⊂T」⇒「数としてS≤T」になるから

rep(S,0,1<<N){
    /*処理*/
}

というふうに、DPの遷移が単純なループで書けることが多いのよね。
この問題もこのことを知っていれば簡単よ。
dp[i][S]=(男性はi人目までで、既にペアになった女性の集合がSであるような場合の数)
としてDPするわ。
今まではずっと1-indexedでやってきたけど、
bitDPは0-indexedの方が都合がいいから、入力は0-indexedで与えられているものとするわ。

#define bit(n,k) ((n>>k)&1) /*nのk bit目*/
dp[0][0]=1;
rep(i,1,N+1)rep(S,0,1<<N){
	rep(j,0,N)if(bit(S,j)==1&&a[i-1][j]==1){
		dp[i][S]=(dp[i][S]+dp[i-1][S^(1<<j)])%MOD;
	}
}
ans=dp[N][(1<<N)-1];

……とすると、これはO(2^N*N^2)でTLEなのよねえ。
少し考えると「既にペアになった女性の集合がS」なら「bitpopcount(S)人目までをチェックした」ってことになるから、
iを状態として持つ必要は無いことがわかるわ。

#define bit(n,k) ((n>>k)&1) /*nのk bit目*/
dp[0]=1;
rep(S,1,1<<N){
	i=__builtin_popcount(S);
	rep(j,0,N)if(bit(S,j)==1&&a[i-1][j]==1)dp[S]=(dp[S]+dp[S^(1<<j)])%MOD;
}
ans=dp[(1<<N)-1];

計算量はO(2^N * N)よ。

詳しくは説明しないけど、
この問題を配るDPで解くときは、次のコードで実はO(2^N * N)になるわ。
枝刈りが本質的に計算量を改善する例ね。

#define bit(n,k) ((n>>k)&1) /*nのk bit目*/
dp[0][0]=1;
//一見するとO(2^N N^2)だけど……
rep(i,0,N)rep(S,0,1<<N)if(dp[i][S]){//<-ここのif文の枝刈りが効いてO(2^N N)に落ちる
	rep(j,0,N)if(bit(S,j)==0&&a[i][j]==1){
		dp[i+1][S^(1<<j)]=(dp[i][S^(1<<j)]+dp[i][S])%MOD;
	}
}
ans=dp[N][(1<<N)-1];"""
#r "nuget: FsUnit"
open FsUnit

"TODO"
let N,Aa = 3,[|[|0;1;1|];[|1;0;1|];[|1;1;1|]|]
let solve N (Aa:int[][]) =
    let memorec f =
        let memo = System.Collections.Generic.Dictionary<_, _>()
        let rec frec j =
            match memo.TryGetValue j with
            | exist, value when exist -> value
            | _ -> let value = f frec j in memo.Add(j, value); value
        frec
    let all = [0..N-1]
    let f frec bset =
        if bset=(1 <<< N-1) then 1
        else
            let i = System.Numerics.BitOperations.PopCount(uint bset)
            let a = all |> List.filter (fun j -> ((bset &&& (1 <<< j)) = 0) && Aa.[i].[j]=1)
            let b = a |> List.map (fun j -> frec (bset ||| (1 <<< j)))
            let c = b |> List.fold (fun x y -> (x+y)%1_000_000_007) 0
            printfn "(a,b,c): %A" (a,b,c)

            all
            |> List.filter (fun j -> ((bset &&& (1 <<< j)) = 0) && Aa.[i].[j]=1)
            |> List.map (fun j -> frec (bset ||| (1 <<< j)))
            |> List.fold (fun x y -> (x+y)%1_000_000_007) 0
    let fmemo = memorec f
    fmemo 0

let N = stdin.ReadLine() |> int
let Aa = [| for i in 1..N do (stdin.ReadLine().Split() |> Array.map int) |]
solve N Aa |> stdout.WriteLine

solve 3 [|[|0;1;1|];[|1;0;1|];[|1;1;1|]|] |> should equal 3
solve 4 [|[|0;1;0;0|];[|0;0;0;1|];[|1;0;0;0|];[|0;0;1;0|]|] |> should equal 1
solve 1 [|[|0|]|] |> should equal 0
solve 21 [|[|0;0;0;0;0;0;0;1;1;0;1;1;1;1;0;0;0;1;0;0;1|];[|1;1;1;0;0;1;0;0;0;1;0;0;0;0;1;1;1;0;1;1;0|];[|0;0;1;1;1;1;0;1;1;0;0;1;0;0;1;1;0;0;0;1;1|];[|0;1;1;0;1;1;0;1;0;1;0;0;1;0;0;0;0;0;1;1;0|];[|1;1;0;0;1;0;1;0;0;1;1;1;1;0;0;0;0;0;0;0;0|];[|0;1;1;0;1;1;1;0;1;1;1;0;0;0;1;1;1;1;0;0;1|];[|0;1;0;0;0;1;0;1;0;0;0;1;1;1;0;0;1;1;0;1;0|];[|0;0;0;0;1;1;0;0;1;1;0;0;0;0;0;1;1;1;1;1;1|];[|0;0;1;0;0;1;0;0;1;0;1;1;0;0;1;0;1;0;1;1;1|];[|0;0;0;0;1;1;0;0;1;1;1;0;0;0;0;1;1;0;0;0;1|];[|0;1;1;0;1;1;0;0;1;1;0;0;0;1;1;1;1;0;1;1;0|];[|0;0;1;0;0;1;1;1;1;0;1;1;0;1;1;1;0;0;0;0;1|];[|0;1;1;0;0;1;1;1;1;0;0;0;1;0;1;1;0;1;0;1;1|];[|1;1;1;1;1;0;0;0;0;1;0;0;1;1;0;1;1;1;0;0;1|];[|0;0;0;1;1;0;1;1;1;1;0;0;0;0;0;0;1;1;1;1;1|];[|1;0;1;1;0;1;0;1;0;0;1;0;0;1;1;0;1;0;1;1;0|];[|0;0;1;1;0;0;1;1;0;0;1;1;0;0;1;1;1;1;0;0;1|];[|0;0;0;1;0;0;1;1;0;1;0;1;0;1;1;0;0;1;1;0;1|];[|0;0;0;0;1;1;1;0;1;0;1;1;1;0;1;1;0;0;1;1;0|];[|1;1;0;1;1;0;0;1;1;0;1;1;0;1;1;1;1;1;0;1;0|];[|1;0;0;1;1;0;1;1;1;1;1;0;1;0;1;1;0;0;0;0;0|]|] |> should equal 102515160
