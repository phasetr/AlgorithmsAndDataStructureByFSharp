# README
- <https://atcoder.jp/contests/dp/tasks/dp_o>

## 問題文
>N 人の男性たちと N 人の女性たちがいます。
>男性たちには 1, 2, \ldots, N と番号が振られています。
>同様に、女性たちには 1, 2, \ldots, N と番号が振られています。
>
>各 i, j (1 \leq i, j \leq N) について、
>男性 i と女性 j の相性の良し悪しが整数 a_{i, j} によって与えられます。
>a_{i, j} = 1 ならば男性 i と女性 j は相性が良く、a_{i, j} = 0 ならば相性が悪いです。
>
>太郎君は、相性が良い男女どうしのペアを N 組作ろうとしています。
>このとき、各男性および各女性はちょうど 1 つのペアに属さなければなりません。
>
>N 組のペアを作る方法は何通りでしょうか？ 10^9 + 7 で割った余りを求めてください。
>
>制約
>
>* 入力はすべて整数である。
>* 1 \leq N \leq 21
>* a_{i, j} は 0 または 1 である。"

## 解説
- <https://kyopro-friends.hatenablog.com/entry/2019/01/12/231035>

>bitDPというテクニックを使う問題ね。
>bitDPというのは、集合を数に変換して状態(=添字)として持つようなDPのことよ。
>例えば{0,2,3}という集合は2^0+2^2+2^3=13という数に変換して、
>「数iが集合に属しているか」と「i bit目が1か」を対応させるわ。
>こうすると、「集合としてS⊂T」⇒「数としてS≤T」になるから
>
>```
>rep(S,0,1<<N){
>    /*処理*/
>}
>```
>
>というふうに、DPの遷移が単純なループで書けることが多いのよね。
>この問題もこのことを知っていれば簡単よ。
>dp[i][S]=(男性はi人目までで、既にペアになった女性の集合がSであるような場合の数)
>としてDPするわ。
>今まではずっと1-indexedでやってきたけど、
>bitDPは0-indexedの方が都合がいいから、入力は0-indexedで与えられているものとするわ。
>
>```
>#define bit(n,k) ((n>>k)&1) /*nのk bit目*/
>dp[0][0]=1;
>rep(i,1,N+1)rep(S,0,1<<N){
>    rep(j,0,N)if(bit(S,j)==1&&a[i-1][j]==1){
>    	dp[i][S]=(dp[i][S]+dp[i-1][S^(1<<j)])%MOD;
>    }
>}
>ans=dp[N][(1<<N)-1];
>```
>
>……とすると、これはO(2^N*N^2)でTLEなのよねえ。
>少し考えると「既にペアになった女性の集合がS」なら「bitpopcount(S)人目までをチェックした」ってことになるから、
>iを状態として持つ必要は無いことがわかるわ。
>
>````
>#define bit(n,k) ((n>>k)&1) /*nのk bit目*/
>dp[0]=1;
>rep(S,1,1<<N){
>    i=__builtin_popcount(S);
>    rep(j,0,N)if(bit(S,j)==1&&a[i-1][j]==1)dp[S]=(dp[S]+dp[S^(1<<j)])%MOD;
>}
>ans=dp[(1<<N)-1];
>```
>
>計算量はO(2^N * N)よ。
>
>詳しくは説明しないけど、
>この問題を配るDPで解くときは、次のコードで実はO(2^N * N)になるわ。
>枝刈りが本質的に計算量を改善する例ね。
>
>````
>#define bit(n,k) ((n>>k)&1) /*nのk bit目*/
>dp[0][0]=1;
>//一見するとO(2^N N^2)だけど……
>rep(i,0,N)rep(S,0,1<<N)if(dp[i][S]){//<-ここのif文の枝刈りが効いてO(2^N N)に落ちる
>    rep(j,0,N)if(bit(S,j)==0&&a[i][j]==1){
>    	dp[i+1][S^(1<<j)]=(dp[i][S^(1<<j)]+dp[i][S])%MOD;
>    }
>}
>ans=dp[N][(1<<N)-1];"""
>```
