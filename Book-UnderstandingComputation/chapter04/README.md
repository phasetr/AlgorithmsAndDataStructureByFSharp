4章 能力を高める
======================

3章で作ったDFAやNFAは、能力に限界がある。たとえばネストレベルの概念を表すことができない。

- ((()))
- (((())))
- (((((())))))

3個の入れ子に対応する、10個の入れ子に対応する、といったことはできるけれど、無限の入れ子にマッチする正規表現やDFAは作れない。

予測できない量の情報を計算中に格納し、それらをあとで再利用するようなタスクの場合、有限オートマトンは使えなくなる。

4.1 決定性プッシュダウン・オートマトン
-------------------------------------

現在の入れ子状態を記録する、外部記憶のようなものを追加できれば、任意個の入れ子を認識することができるはずだ。

組み込みのスタックを持つ有限状態機械はプッシュダウン・オートマトン（PDA: Pushdown Automaton）と言う。決定的である場合は決定性プッシュダウン・オートマトン（DPDA: Deterministic Pushdown Automaton) と呼ばれる。

### 4.1.2 規則

単純化するため、PDAは規則に従うたびに、常にスタックのトップにある文字をポップし、そのあとスタックに文字をいくつかプッシュする。そういう規則にする。

以降、a;b/cdという表記は、以下の3つの動作を表すものとする。(表記法)

1. 入力をaから読み
2. スタックからbをポップし、
3. スタックにcdをプッシュする


### 4.1.4 シミュレーション

rubyでDPDAをシミュレーションする。

- Stack(:contents) スタック構造
  - #push(character) 文字をpushした新たなスタックを作って返す
  - #pop(character) 文字を一つ落とした新たなスタックを作って返す
  - #top 現在のスタックのトップにある文字を返す。状態は変更しない
  - #inspect
- PDAConfiguration(:state, :stack) 状態とスタックを保持する
  - #stuck 行き詰まり状態を返す
  - #stuck? 現在行き詰まり状態なのかを返す
- PDARule(:state, :character, :next_state, :pop_character, :push_characters) 一つの規則を表す
  - #applies_to?(configuration, character) 与えられたconfと1文字から、この規則が適用できるか判定する。
  - #follow(configuration) この規則に従う。confを変更した新たなconfを返す。
  - #next_stack(configuration) 内部向け。次のstackを返す。

- DPDARulebook(:rules) DPDA規則集。PDARuleをまとめたもの。
  - #next_configuration(configuration, character) 文字を読み取って次のconfを返す。
  - #rule_for(configuration, character) 内部用。文字から適用可能なruleを探し出す
  - #applies_to?(configuration, character) 自由移動がないか判定する
  - #follow_free_moves(configuration) 可能な自由移動がある限り移動する

- DPDA(:current_configuration, :accept_state, :rulebook) 入力から文字を読みながら現在の構成を記録できる
  - #accpeting? 現在の状態は受理状態か判定する
  - #read_character(character)
  - #read_string(string) 文字列を受けて状態およびconfを変更してゆく
  - #current_configuration 自由移動をしたのちに現在のconfを返す
  - #next_configuration(character) 適用可能であれば変更し、
  - #stuck? このDPDAが行き詰ったか調べる

- DPDADesign(:start_state, :bottom_character, :accept_state, :rulebook) 何度でもDPDAを作成できるような設計書
  - #accepts?(string) この文字列を受理するか？
  - to_dpda DPDAオブジェクトを作成して返す


4.2 非決定性プッシュダウン・オートマトン
----------------------------------

もっと高機能なDPDAでは、スタックに複数のシンボルをプッシュして、その情報を使って計算を実行する。
先ほどのDPDAシミュレーションでは、例えばaとbの文字を同数だけ含んだ文字列を認識する機械を作ることもできる。
ただ、あまりスタックを活用しているとは言えない。

スタックをもっと活用した例として、回文の認識がある。

入力文字列を一文字ずつ読みながら、これまで見てきた文字列が逆順に登場するか確認すればよい。

文字列の中央にマーカー文字mあるとすれば、DPDAでも回文を認識できる。
しかし通常はマーカー文字などないので、どこが文の真ん中なのかわからない。いつ折り返しの挙動をすればいいかわからないので、決定的なプッシュダウン・オートマトンだとうまく作ることができない。

そこで、非決定性のプッシュダウン・オートマトン(NPDA: Nondeterministic Pushdown Automaton)を考えてみると、回文認識も可能になる。


### 4.2.2 非等価性

NFAをDFAでシミュレーションすることが可能であることは、前に述べた。
これはプッシュダウン・オートマトンでも当てはまるのだろうか？

結論から言えば、NPDAをDPDAに変換するアルゴリズムは存在しないことがわかっている。
複数のNPDA構成を、一つのDPDA構成としてうまく表現することはできない。

つまり、NPDAはDPDAよりも能力が高いと言える。


4.3 プッシュダウン・オートマトンによるパース
--------------------------------------

プッシュダウン・オートマトンの応用例として、言語のパースがある。
Treetopで行ったようなパース表現文法を使ってパースされる言語の完全な構文を記述するのではなく、伝統的なアプローチではNPDAを使うことができる。

1. 字句解析(Lexical analysis)
  - 生の文字列からトークン(token)のシーケンスに変換する
2. 構文解析(Syntactic analysis)
  - トークンのシーケンスから構文文法に従っているか判断し、構文木を生成する


4.4 どれだけ能力があるか
--------------------------------------

DPDAはDFAやNFAより能力が高く、NPDAはDPDAより更に能力が高い。
しかしながら、汎用コンピュータとしてはまだまだ非力である。
例えばPDAは回文を認識できるが、'baaabaaa'などの2回繰り返す文字列を認識できない。スタックの蓄え順と逆の順序でないと読み出せないからだ。

次の章では汎用コンピュータのモデルであるチューリングマシンについて理解を深めてゆく。
